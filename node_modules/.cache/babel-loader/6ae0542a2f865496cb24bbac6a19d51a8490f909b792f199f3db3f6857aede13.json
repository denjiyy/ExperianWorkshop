{"ast":null,"code":"import { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\nimport { setCredentials, logOut } from \"./authSlice\";\n// import { BaseQueryApi } from \"../types/baseQuery\"\nconst baseQuery = fetchBaseQuery({\n  baseUrl: 'http://localhost:7223',\n  credentials: 'include',\n  prepareHeaders: (headers, {\n    getState\n  }) => {\n    const state = getState();\n    //const state = getState() as RootState\n\n    const token = state.auth.token;\n    if (token) {\n      headers.set(\"Authorization\", `Bearer ${token}`);\n    }\n    return headers;\n  }\n});\nconst baseQueryWithReauth = async (args, api, extraOptions) => {\n  var _result, _result$error;\n  let result = await baseQuery(args, api, extraOptions);\n  if (((_result = result) === null || _result === void 0 ? void 0 : (_result$error = _result.error) === null || _result$error === void 0 ? void 0 : _result$error.status) === 403) {\n    console.log('sending refresh token');\n    //send refresh token to get new access token\n    const refreshResult = await baseQuery('api/auth', api, extraOptions);\n    console.log(refreshResult);\n    if (refreshResult !== null && refreshResult !== void 0 && refreshResult.data) {\n      const state = api.getState();\n      const user = state.auth.user;\n      //store the new token\n      api.dispatch(setCredentials({\n        ...refreshResult.data,\n        user\n      }));\n      //possibly have to change the order for the dispatch of the parameters\n\n      //retry original query with new access token\n      result = await baseQuery(args, api, extraOptions);\n    } else {\n      api.dispatch(logOut());\n    }\n  }\n  return result;\n};\nexport const apiSlice = createApi({\n  baseQuery: baseQueryWithReauth,\n  endpoints: builder => ({})\n});\n\n// check if the endpoint is being ppsoted to the db\n//debug the endpoint\n\n// export const apiSlice = createApi({\n//     baseQuery:fetchBaseQuery({\n//         baseUrl:'http://localhost:7223',\n//         credentials:'include',\n//         prepareHeaders:(headers,{getState})=>{\n//             const state = getState() as any\n//             //const state = getState() as RootState\n\n//              const token = state.auth.token\n//             if(token){\n//                 headers.set(\"Authorization\",`Bearer ${token}`) \n\n//             }\n//             return headers\n//         }\n//     }),\n//     tagTypes:[\"auth\"],\n//     endpoints:builder=>({})\n// })\n// credentials will send back http-only cookie\n\n//baseQueryReAUth - wrapper that reattempts to see if an acess token has expired\n//refreshResult?.data - the user should already be logged in case we are logged","map":{"version":3,"names":["createApi","fetchBaseQuery","setCredentials","logOut","baseQuery","baseUrl","credentials","prepareHeaders","headers","getState","state","token","auth","set","baseQueryWithReauth","args","api","extraOptions","_result","_result$error","result","error","status","console","log","refreshResult","data","user","dispatch","apiSlice","endpoints","builder"],"sources":["D:/experianProject/experian/ExperianWorkshop/src/actions/apiSlice.ts"],"sourcesContent":["import {createApi,fetchBaseQuery,FetchArgs,FetchBaseQueryError,BaseQueryFn, BaseQueryApi} from \"@reduxjs/toolkit/query/react\"\r\nimport { setCredentials,logOut } from \"./authSlice\"\r\nimport {RootState} from './store'\r\n// import { BaseQueryApi } from \"../types/baseQuery\"\r\nconst baseQuery = fetchBaseQuery({\r\n    baseUrl:'http://localhost:7223',\r\n    credentials:'include',\r\n    prepareHeaders:(headers,{getState})=>{\r\n        const state = getState() as any\r\n        //const state = getState() as RootState\r\n        \r\n         const token = state.auth.token\r\n        if(token){\r\n            headers.set(\"Authorization\",`Bearer ${token}`) \r\n\r\n        }\r\n        return headers\r\n    }\r\n})\r\n\r\nconst baseQueryWithReauth: BaseQueryFn<\r\nstring | FetchArgs, \r\nunknown,\r\nFetchBaseQueryError\r\n> = async(args,api,extraOptions)=>{\r\n    let result = await baseQuery(args,api,extraOptions)\r\n    if(result?.error?.status===403){\r\n        console.log('sending refresh token')\r\n        //send refresh token to get new access token\r\n        const refreshResult = await baseQuery('api/auth',api,extraOptions)\r\n        console.log(refreshResult)\r\n        if(refreshResult?.data){\r\n            const state = api.getState() as any\r\n            const user = state.auth.user\r\n            //store the new token\r\n            api.dispatch(setCredentials({...refreshResult.data,user}))\r\n            //possibly have to change the order for the dispatch of the parameters\r\n\r\n            //retry original query with new access token\r\n            result = await baseQuery(args,api,extraOptions)\r\n        }else{\r\n            api.dispatch(logOut())\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexport const apiSlice = createApi({\r\n    baseQuery:baseQueryWithReauth,\r\n    endpoints : builder =>({}),\r\n})\r\n\r\n// check if the endpoint is being ppsoted to the db\r\n//debug the endpoint\r\n\r\n// export const apiSlice = createApi({\r\n//     baseQuery:fetchBaseQuery({\r\n//         baseUrl:'http://localhost:7223',\r\n//         credentials:'include',\r\n//         prepareHeaders:(headers,{getState})=>{\r\n//             const state = getState() as any\r\n//             //const state = getState() as RootState\r\n            \r\n//              const token = state.auth.token\r\n//             if(token){\r\n//                 headers.set(\"Authorization\",`Bearer ${token}`) \r\n    \r\n//             }\r\n//             return headers\r\n//         }\r\n//     }),\r\n//     tagTypes:[\"auth\"],\r\n//     endpoints:builder=>({})\r\n// })\r\n// credentials will send back http-only cookie\r\n\r\n//baseQueryReAUth - wrapper that reattempts to see if an acess token has expired\r\n//refreshResult?.data - the user should already be logged in case we are logged\r\n"],"mappings":"AAAA,SAAQA,SAAS,EAACC,cAAc,QAA+D,8BAA8B;AAC7H,SAASC,cAAc,EAACC,MAAM,QAAQ,aAAa;AAEnD;AACA,MAAMC,SAAS,GAAGH,cAAc,CAAC;EAC7BI,OAAO,EAAC,uBAAuB;EAC/BC,WAAW,EAAC,SAAS;EACrBC,cAAc,EAACA,CAACC,OAAO,EAAC;IAACC;EAAQ,CAAC,KAAG;IACjC,MAAMC,KAAK,GAAGD,QAAQ,CAAC,CAAQ;IAC/B;;IAEC,MAAME,KAAK,GAAGD,KAAK,CAACE,IAAI,CAACD,KAAK;IAC/B,IAAGA,KAAK,EAAC;MACLH,OAAO,CAACK,GAAG,CAAC,eAAe,EAAC,UAAUF,KAAK,EAAE,CAAC;IAElD;IACA,OAAOH,OAAO;EAClB;AACJ,CAAC,CAAC;AAEF,MAAMM,mBAIL,GAAG,MAAAA,CAAMC,IAAI,EAACC,GAAG,EAACC,YAAY,KAAG;EAAA,IAAAC,OAAA,EAAAC,aAAA;EAC9B,IAAIC,MAAM,GAAG,MAAMhB,SAAS,CAACW,IAAI,EAACC,GAAG,EAACC,YAAY,CAAC;EACnD,IAAG,EAAAC,OAAA,GAAAE,MAAM,cAAAF,OAAA,wBAAAC,aAAA,GAAND,OAAA,CAAQG,KAAK,cAAAF,aAAA,uBAAbA,aAAA,CAAeG,MAAM,MAAG,GAAG,EAAC;IAC3BC,OAAO,CAACC,GAAG,CAAC,uBAAuB,CAAC;IACpC;IACA,MAAMC,aAAa,GAAG,MAAMrB,SAAS,CAAC,UAAU,EAACY,GAAG,EAACC,YAAY,CAAC;IAClEM,OAAO,CAACC,GAAG,CAACC,aAAa,CAAC;IAC1B,IAAGA,aAAa,aAAbA,aAAa,eAAbA,aAAa,CAAEC,IAAI,EAAC;MACnB,MAAMhB,KAAK,GAAGM,GAAG,CAACP,QAAQ,CAAC,CAAQ;MACnC,MAAMkB,IAAI,GAAGjB,KAAK,CAACE,IAAI,CAACe,IAAI;MAC5B;MACAX,GAAG,CAACY,QAAQ,CAAC1B,cAAc,CAAC;QAAC,GAAGuB,aAAa,CAACC,IAAI;QAACC;MAAI,CAAC,CAAC,CAAC;MAC1D;;MAEA;MACAP,MAAM,GAAG,MAAMhB,SAAS,CAACW,IAAI,EAACC,GAAG,EAACC,YAAY,CAAC;IACnD,CAAC,MAAI;MACDD,GAAG,CAACY,QAAQ,CAACzB,MAAM,CAAC,CAAC,CAAC;IAC1B;EACJ;EACA,OAAOiB,MAAM;AACjB,CAAC;AACD,OAAO,MAAMS,QAAQ,GAAG7B,SAAS,CAAC;EAC9BI,SAAS,EAACU,mBAAmB;EAC7BgB,SAAS,EAAGC,OAAO,KAAI,CAAC,CAAC;AAC7B,CAAC,CAAC;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}